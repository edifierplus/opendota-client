# coding: utf-8

"""
    OpenDota API

    # Introduction The OpenDota API provides Dota 2 related data including advanced match data extracted from match replays.  You can find data that can be used to convert hero and ability IDs and other information provided by the API from the [dotaconstants](https://github.com/odota/dotaconstants) repository.  **Beginning 2018-04-22, the OpenDota API is limited to 50,000 free calls per month and 60 requests/minute** We offer a Premium Tier with unlimited API calls and higher rate limits. Check out the [API page](https://www.opendota.com/api-keys) to learn more.   # noqa: E501

    OpenAPI spec version: 18.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from opendota_client.api_client import ApiClient


class PlayersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def players_account_id_counts_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/counts  # noqa: E501

        Counts in categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_counts_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_counts_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_counts_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_counts_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/counts  # noqa: E501

        Counts in categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_counts_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_counts_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_counts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}  # noqa: E501

        Player data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}  # noqa: E501

        Player data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_heroes_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/heroes  # noqa: E501

        Heroes played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_heroes_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2006]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_heroes_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_heroes_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_heroes_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/heroes  # noqa: E501

        Heroes played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_heroes_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2006]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_heroes_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_heroes_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/heroes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2006]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_histograms_field_get(self, account_id, field, **kwargs):  # noqa: E501
        """GET /players/{account_id}/histograms  # noqa: E501

        Distribution of matches in a single stat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_histograms_field_get(account_id, field, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param str field: Field to aggregate on (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_histograms_field_get_with_http_info(account_id, field, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_histograms_field_get_with_http_info(account_id, field, **kwargs)  # noqa: E501
            return data

    def players_account_id_histograms_field_get_with_http_info(self, account_id, field, **kwargs):  # noqa: E501
        """GET /players/{account_id}/histograms  # noqa: E501

        Distribution of matches in a single stat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_histograms_field_get_with_http_info(account_id, field, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param str field: Field to aggregate on (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'field', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_histograms_field_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_histograms_field_get`")  # noqa: E501
        # verify the required parameter 'field' is set
        if ('field' not in params or
                params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `players_account_id_histograms_field_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'field' in params:
            path_params['field'] = params['field']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/histograms/{field}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_matches_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/matches  # noqa: E501

        Matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_matches_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :param str project: Fields to project (array)
        :return: list[InlineResponse2005]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_matches_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_matches_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_matches_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/matches  # noqa: E501

        Matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_matches_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :param str project: Fields to project (array)
        :return: list[InlineResponse2005]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort', 'project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_matches_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_matches_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'project' in params:
            query_params.append(('project', params['project']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/matches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2005]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_peers_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/peers  # noqa: E501

        Players played with  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_peers_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2007]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_peers_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_peers_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_peers_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/peers  # noqa: E501

        Players played with  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_peers_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2007]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_peers_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_peers_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/peers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2007]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_pros_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/pros  # noqa: E501

        Pro players played with  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_pros_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2008]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_pros_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_pros_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_pros_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/pros  # noqa: E501

        Pro players played with  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_pros_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2008]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_pros_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_pros_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/pros', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2008]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_rankings_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/rankings  # noqa: E501

        Player hero rankings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_rankings_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_rankings_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_rankings_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_rankings_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/rankings  # noqa: E501

        Player hero rankings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_rankings_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_rankings_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_rankings_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/rankings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_ratings_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/ratings  # noqa: E501

        Player rating history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_ratings_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: list[InlineResponse20013]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_ratings_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_ratings_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_ratings_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/ratings  # noqa: E501

        Player rating history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_ratings_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: list[InlineResponse20013]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_ratings_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_ratings_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/ratings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20013]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_recent_matches_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/recentMatches  # noqa: E501

        Recent matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_recent_matches_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: list[InlineResponse2004]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_recent_matches_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_recent_matches_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_recent_matches_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/recentMatches  # noqa: E501

        Recent matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_recent_matches_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: list[InlineResponse2004]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_recent_matches_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_recent_matches_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/recentMatches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2004]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_refresh_post(self, account_id, **kwargs):  # noqa: E501
        """POST /players/{account_id}/refresh  # noqa: E501

        Refresh player match history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_refresh_post(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_refresh_post_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_refresh_post_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_refresh_post_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """POST /players/{account_id}/refresh  # noqa: E501

        Refresh player match history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_refresh_post_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_refresh_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_refresh_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/refresh', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_totals_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/totals  # noqa: E501

        Totals in stats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_totals_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2009]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_totals_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_totals_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_totals_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/totals  # noqa: E501

        Totals in stats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_totals_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: list[InlineResponse2009]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_totals_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_totals_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/totals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2009]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_wardmap_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/wardmap  # noqa: E501

        Wards placed in matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_wardmap_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_wardmap_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_wardmap_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_wardmap_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/wardmap  # noqa: E501

        Wards placed in matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_wardmap_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_wardmap_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_wardmap_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/wardmap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_wl_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/wl  # noqa: E501

        Win/Loss count  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_wl_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_wl_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_wl_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_wl_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/wl  # noqa: E501

        Win/Loss count  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_wl_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_wl_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_wl_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/wl', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def players_account_id_wordcloud_get(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/wordcloud  # noqa: E501

        Words said/read in matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_wordcloud_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.players_account_id_wordcloud_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.players_account_id_wordcloud_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def players_account_id_wordcloud_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """GET /players/{account_id}/wordcloud  # noqa: E501

        Words said/read in matches played  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.players_account_id_wordcloud_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Steam32 account ID (required)
        :param int limit: Number of matches to limit to
        :param int offset: Number of matches to offset start by
        :param int win: Whether the player won
        :param int patch: Patch ID
        :param int game_mode: Game Mode ID
        :param int lobby_type: Lobby type ID
        :param int region: Region ID
        :param int _date: Days previous
        :param int lane_role: Lane Role ID
        :param int hero_id: Hero ID
        :param int is_radiant: Whether the player was radiant
        :param int included_account_id: Account IDs in the match (array)
        :param int excluded_account_id: Account IDs not in the match (array)
        :param int with_hero_id: Hero IDs on the player's team (array)
        :param int against_hero_id: Hero IDs against the player's team (array)
        :param int significant: Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
        :param int having: The minimum number of games played, for filtering hero stats
        :param str sort: The field to return matches sorted by in descending order
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'limit', 'offset', 'win', 'patch', 'game_mode', 'lobby_type', 'region', '_date', 'lane_role', 'hero_id', 'is_radiant', 'included_account_id', 'excluded_account_id', 'with_hero_id', 'against_hero_id', 'significant', 'having', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method players_account_id_wordcloud_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `players_account_id_wordcloud_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'win' in params:
            query_params.append(('win', params['win']))  # noqa: E501
        if 'patch' in params:
            query_params.append(('patch', params['patch']))  # noqa: E501
        if 'game_mode' in params:
            query_params.append(('game_mode', params['game_mode']))  # noqa: E501
        if 'lobby_type' in params:
            query_params.append(('lobby_type', params['lobby_type']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'lane_role' in params:
            query_params.append(('lane_role', params['lane_role']))  # noqa: E501
        if 'hero_id' in params:
            query_params.append(('hero_id', params['hero_id']))  # noqa: E501
        if 'is_radiant' in params:
            query_params.append(('is_radiant', params['is_radiant']))  # noqa: E501
        if 'included_account_id' in params:
            query_params.append(('included_account_id', params['included_account_id']))  # noqa: E501
        if 'excluded_account_id' in params:
            query_params.append(('excluded_account_id', params['excluded_account_id']))  # noqa: E501
        if 'with_hero_id' in params:
            query_params.append(('with_hero_id', params['with_hero_id']))  # noqa: E501
        if 'against_hero_id' in params:
            query_params.append(('against_hero_id', params['against_hero_id']))  # noqa: E501
        if 'significant' in params:
            query_params.append(('significant', params['significant']))  # noqa: E501
        if 'having' in params:
            query_params.append(('having', params['having']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/players/{account_id}/wordcloud', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
